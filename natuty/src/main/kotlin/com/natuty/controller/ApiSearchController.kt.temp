package com.natuty.controller

import com.natuty.entity.Search
import com.natuty.entity.SelectType
import com.natuty.exception.BusinessException
import com.natuty.service.*
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.data.domain.PageRequest
import org.springframework.web.bind.annotation.RequestParam

import org.apache.lucene.search.Query;
import org.springframework.data.domain.PageImpl
import java.util.ArrayList
import org.apache.lucene.search.BooleanClause.Occur
import org.wltea.analyzer.lucene.IKAnalyzer
import org.apache.lucene.queryparser.classic.MultiFieldQueryParser
import org.apache.lucene.search.MatchAllDocsQuery
import org.apache.lucene.search.BooleanQuery
import org.springframework.boot.context.properties.ConfigurationProperties
import org.apache.lucene.search.IndexSearcher
import org.apache.lucene.index.DirectoryReader
import org.apache.lucene.store.FSDirectory
import java.io.File
import org.apache.lucene.search.ScoreDoc
import org.apache.lucene.search.Sort;
import org.apache.lucene.search.highlight.TokenSources
import org.apache.lucene.search.highlight.SimpleHTMLFormatter
import org.apache.lucene.search.highlight.QueryScorer
import org.apache.lucene.document.TextField;
import org.apache.lucene.search.highlight.Highlighter;
import org.apache.lucene.analysis.TokenStream;
import org.apache.lucene.document.Field.Store;
import org.apache.lucene.document.Document;
import org.springframework.web.multipart.MultipartFile
import org.slf4j.LoggerFactory
import java.util.regex.Pattern


@RestController
@RequestMapping("/api/apisearch")
@ConfigurationProperties("scut.file")
class ApiSearchController(
        val apiSearchServiceI: ApiSearchServiceI,
        val apiLuceneServiceI: ApiLuceneServiceI
) {

    var indexDir = ""
    var pdfDir = ""

    val log = LoggerFactory.getLogger(this.javaClass)

    /**
     * 上传文件
     */
    @RequestMapping("/uploadFile")
    fun uploadFile(file: MultipartFile, fileId: String): Any {

        var status = true
        try {

            val pattern = "[\\s\\\\/:\\*\\?\\\"<>\\|]"
            if(Pattern.compile(pattern).matcher(fileId).find()){
                throw BusinessException("文件ID不正确")
            }

            if(fileId == "") return throw BusinessException("文件ID不能为空")
            val extension = file.originalFilename.split('.').run { this[this.size - 1] }
            val isContain = arrayListOf("pdf","doc","docx").contains(extension)
            if (!isContain) return BusinessException("请上传pdf,doc,dox文件")
            apiSearchServiceI.saveFile(file, fileId)
        } catch (e: Exception) {
            e.printStackTrace()
            status = false
            val search  = apiSearchServiceI.getFirstByFileId(fileId = fileId)
            if(search == null){
                val filePath = pdfDir + File.separator + fileId + File.separator + file.originalFilename
                val saveFile = File(filePath)
                if(saveFile.exists()){
                    saveFile.delete()
                }
            }
        }
        val rt = hashMapOf(
                "status" to status
        )
        return rt
    }

    /**
     * 下载文件
     */
    @RequestMapping("/downloadFile")
    
    fun downloadFile(fileId: String): Any? {
        return apiSearchServiceI.getFile(fileId = fileId)
    }

    /**
     * 检索
     * */
    @RequestMapping("/query")
    fun query(selectType: SelectType?, searchWord: String? = "", current: Int? = 0, pageSize: Int? = 10): Any? {
        var cur = (current ?: 0) - 1
        var page = pageSize ?: 10
        if (cur < 0) cur = 0
        if (page < 0) page = 10
        else if (page > 560) page = 100

        var rt: Any
        try {
            rt = apiSearchServiceI.doSearch(selectType = selectType, searchWord = searchWord, pageable = PageRequest(cur, page))
        } catch (e: Exception) {
            e.printStackTrace()
            rt = hashMapOf("status" to false)
        }
        return rt
    }

    /**
     * 删除文件
     * */
    @RequestMapping("/deleteFile")
    fun deleteFile(fileId: String): Any? {
        var status = true
        try {
            val search = apiSearchServiceI.getFirstByFileId(fileId = fileId)?: throw BusinessException("删除索引出错")
            apiLuceneServiceI.deleteIndex(arrayListOf(search))
        } catch (e: Exception) {
            e.printStackTrace()
            status = false
        }

        val rt = hashMapOf(
                "status" to status
        )
        return rt
    }

    /**
     * 获取文本内容
     * */
    @RequestMapping("/getFileText")
    fun getFileText(fileId: String): Any? {
        var status = true
        var text = ""
        try {
            val search = apiSearchServiceI.getFirstByFileId(fileId = fileId) ?: throw BusinessException("获取pdf文本内容出错")
            val pdfFilePath = pdfDir + File.separator + search.relativePath
            text = apiLuceneServiceI.getTextFromFile(pdfFilePath)
        } catch (e: Exception) {
            e.printStackTrace()
            status = false
        }

        val rt = hashMapOf(
                "text" to text,
                "status" to status
        )
        return rt
    }
}