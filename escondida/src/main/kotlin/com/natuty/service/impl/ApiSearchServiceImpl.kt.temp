package com.natuty.service.impl

import org.slf4j.LoggerFactory
import com.natuty.dao.ApiSearchDaoI
import com.natuty.entity.Search
import com.natuty.entity.SelectType
import com.natuty.exception.BusinessException
import com.natuty.service.ApiLuceneServiceI
import com.natuty.service.ApiSearchServiceI
import org.apache.lucene.analysis.TokenStream
import org.apache.lucene.document.Document
import org.apache.lucene.document.Field
import org.apache.lucene.document.TextField
import org.apache.lucene.index.DirectoryReader
import org.apache.lucene.queryparser.classic.MultiFieldQueryParser
import org.apache.lucene.search.*
import org.apache.lucene.search.highlight.Highlighter
import org.apache.lucene.search.highlight.QueryScorer
import org.apache.lucene.search.highlight.SimpleHTMLFormatter
import org.apache.lucene.search.highlight.TokenSources
import org.apache.lucene.store.FSDirectory
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.ApplicationContext
import org.springframework.stereotype.Service
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.domain.Specification
import org.springframework.data.domain.Page
import org.springframework.scheduling.annotation.Scheduled
import org.wltea.analyzer.lucene.IKAnalyzer
import java.lang.Exception
import java.util.ArrayList

import org.apache.lucene.util.Version
import org.apache.lucene.index.IndexWriter
import org.apache.lucene.index.IndexWriterConfig
import org.apache.lucene.index.IndexWriterConfig.OpenMode;
import org.apache.lucene.index.Term
import org.apache.pdfbox.pdmodel.PDDocument
import org.apache.pdfbox.text.PDFTextStripper
import org.springframework.web.multipart.MultipartFile
import java.io.*
import org.springframework.transaction.annotation.Transactional
import org.springframework.http.HttpHeaders
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import java.net.URLEncoder


@Service
@Transactional
@ConfigurationProperties("scut.file")
class ApiSearchServiceImpl(
        val applicationContext: ApplicationContext,
        val searchDaoI: ApiSearchDaoI
) : ApiSearchServiceI {

    var indexDir = ""
    var pdfDir = ""
    val log = LoggerFactory.getLogger(ApiSearchServiceImpl::class.java)
    var downLoadSize = 1024000000

    val apiLuceneServiceI: ApiLuceneServiceI by lazy {
        applicationContext.getBean(ApiLuceneServiceI::class.java)
    }


    override fun get(id: Long): Search? {
        return searchDaoI.get(id)
    }

    override fun save(search: Search): Search {
        return searchDaoI.save(search = search)
    }

    override fun delete(id: Long) {
        searchDaoI.delete(id = id)
    }

    override fun delete(ids: List<Long>) {
        searchDaoI.delete(ids = ids)
    }

    override fun deleteAll() {
        searchDaoI.deleteAll()
    }

    override fun query(spec: Specification<Search>?, pageable: Pageable): Page<Search> {
        return searchDaoI.query(spec = spec, pageable = pageable)
    }

    override fun getFirstByFileId(fileId: String): Search? {
        return searchDaoI.getFirstByFileId(fileId = fileId)
    }


    override fun getAllByIsIndex(isIndex: Boolean): List<Search> {
        return searchDaoI.getAllByIsIndex(isIndex = isIndex)
    }

    override fun findByIdIn(ids: List<Long>, pageable: Pageable): Page<Search> {
        return searchDaoI.findByIdIn(ids = ids, pageable = pageable)
    }


    //检索处理部分
    override fun doSearch(selectType: SelectType?, searchWord: String?, pageable: Pageable): Any {

        val docList: MutableList<Document> = apiLuceneServiceI.doSearch(selectType = selectType, searchWord = searchWord, pageable = pageable)
        var ids = mutableListOf<Long>()

        docList.forEach { it ->
            ids.add(it.get("id").toLong())
        }

        var pagelist = findByIdIn(ids, pageable = pageable)
        val content = pagelist.content.sortedBy ({ ids.indexOf(it.id) })

        var rt = pagelist.map { hashMapOf( "id" to it.id ) }

        var content2 = content.map {
            val doc = docList.filter { item -> item.get("id") == "" + it.id }.firstOrNull()
            val content: String = doc?.get("content") ?: ""
            val content3: String = doc?.get("content3") ?: ""
            hashMapOf(
                    "id" to it.id,
                    "content" to content,
                    "fileId" to it.fileId,
                    "isIndex" to it.isIndex,
                    "filename" to it.filename,
                    "content" to content3
            )
        }

        val rt2 = hashMapOf(
                "content" to content2,
                "pageable" to rt.pageable,
                "totalPages" to rt.totalPages,
                "totalElements" to rt.totalElements,
                "number" to rt.number,
                "size" to rt.size,
                "sort" to rt.sort,
                "numberOfElements" to rt.numberOfElements,
                "first" to rt.isFirst,
                "status" to true
        )

        return rt2
    }

    override fun saveFile(file: MultipartFile, fileId: String):Search? {
        log.info("保存上传文件${file.originalFilename}")

        var saveFilePath = pdfDir + File.separatorChar + fileId + File.separator + file.originalFilename

        var fileDir = File(pdfDir + File.separator + fileId)
        if(!fileDir.exists()){
            fileDir.mkdir()
        }

        val saveFile = File(saveFilePath)
        if (saveFile.exists()) {
            throw BusinessException("文件已存在")
        }
        file.transferTo(saveFile)

        log.info("文件保存到$saveFilePath")
        val search = apiLuceneServiceI.addIndex(saveFilePath, fileId)
        return search
    }

    override fun getFile(fileId: String):Any? {

        val search = getFirstByFileId(fileId = fileId) ?: throw BusinessException("没有找到文件")
        val filePath = pdfDir + File.separator + search.relativePath
        log.info("\n正在下载文件:"+filePath)
        val file = File(filePath)

        if (!file.exists()) throw BusinessException("没有找到文件")
        var headers = HttpHeaders()
        val filename = URLEncoder.encode(search.filename,"UTF-8")
        headers.add("Content-Disposition", "attachment;filename=" + filename)
        return ResponseEntity<ByteArray>(file.readBytes(), headers, HttpStatus.OK)
    }

    override fun pdfIndex(writer: IndexWriter, pdfPath: String, fileId: String): Search? {
        var search: Search? = null
        val file = File(pdfPath)
        var fis: FileInputStream? = null;
        if (file.isFile) {
            val filename = file.getName()
            fis = FileInputStream(file)

            val extension = file.extension
            val isContain = arrayListOf("pdf","doc","docx").contains(extension)

            if (isContain) {
                val doc = Document()
                val content = apiLuceneServiceI.getTextFromFile(pdfPath)
                search = getFirstByFileId(fileId = fileId)
                if (search?.isIndex ?: false == false) {
                    search = search ?: Search(
                            filename = filename,
                            relativePath = fileId + File.separator + filename,
                            isIndex = true,
                            fileId = fileId,
                            fsize = file.length()
                    )

                    search.isIndex = true
                    search = searchDaoI.save(search)

                    doc.add(Field("content", content, TextField.TYPE_STORED));
                    doc.add(Field("filename", filename, TextField.TYPE_STORED));
                    doc.add(Field("id", "" + search.id, Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS))

                    if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {
                        writer.addDocument(doc);
                    } else {
                        writer.updateDocument(Term("filename", filename), doc);
                    }
                    writer.commit()
                }
            }
            fis.close();
        } else {
            val filename = file.name
            file.list().forEach { path ->
                pdfIndex(writer, pdfPath + File.separator + path, fileId = filename)
            }
        }

        return search
    }

    //文件复制
    fun fileCopy(originFile: File, targetPath: String) {
        val file = File(targetPath)
        val parentFile =  File(file.parent)
        if(!parentFile.exists()){
            parentFile.mkdir()
        }

        val inputStrean = originFile.inputStream()
        val out = FileOutputStream(targetPath)
        inputStrean.copyTo(out)
        inputStrean.close()
        out.close()
    }

}